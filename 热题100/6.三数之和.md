# 题目
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。
- 示例 1：
  - 输入：nums = [-1,0,1,2,-1,-4]
  - 输出：[[-1,-1,2],[-1,0,1]]
  - 解释：索引可以不同，输出的看值<br/>
    nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 <br/>
    nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 <br/>
    nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 <br/>
    不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br/>
    注意，输出的顺序和三元组的顺序并不重要。
# 自解
- 暴力：双循环
  - 外层循环i固定索引初始值，内层循环j不断扩大，外层循环i+1重复内循环
```java

```
# 原解
- 
```java

```
# 知识点
1. 数组相关
```java
//创建数组
int[] arr = new int[5];
int[] arr = {1,2,3,4,5};

//排序
Arrays.sort(arr);
```
2. List相关
```java
//创建List
List<Integer> list = new ArrayList<>();

//添加元素
list.add(1);
list.addAll(Arrays.asList(1,2,3,4,5));

//获取元素
int value= list.get(index);

//删除元素
list.remove(index); //按索引删除
list.remove(Integer.valueOdf(1));  //按值删除

//包含检查
list.contains(1);

// 数组转List（注意：基本类型数组需要特殊处理）
int[] nums = {1,2,3};
List<Integer> list = Arrays.stream(nums).boxed().collect(Collectors.toList());
// 或者对于Integer数组
Integer[] nums = {1,2,3};
List<Integer> list = Arrays.asList(nums);  // 返回的是固定大小的List


```
# 总结

3. Map相关
java
// 创建Map
Map<Integer, Integer> map = new HashMap<>();

// 添加元素
map.put(key, value);

// 获取元素
Integer value = map.get(key);

// 检查是否包含key
boolean contains = map.containsKey(key);

// 检查是否包含value
boolean contains = map.containsValue(value);

// 遍历Map
for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
    int key = entry.getKey();
    int value = entry.getValue();
}
4. Collections工具类
java
// 排序
Collections.sort(list);

// 反转
Collections.reverse(list);

// 最大值最小值
int max = Collections.max(list);
int min = Collections.min(list);
二、正确解决三数之和问题
这是一个正确的双指针解法：

java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        
        // 先排序
        Arrays.sort(nums);
        
        for (int i = 0; i < nums.length - 2; i++) {
            // 跳过重复元素
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            
            int left = i + 1;
            int right = nums.length - 1;
            int target = -nums[i];
            
            while (left < right) {
                int sum = nums[left] + nums[right];
                
                if (sum == target) {
                    // 找到符合条件的三个数
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    
                    // 跳过重复的left
                    while (left < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    // 跳过重复的right
                    while (left < right && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    
                    left++;
                    right--;
                } else if (sum < target) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        
        return result;
    }
}
三、如果你想尝试使用Map的方法，这里有个示例：
java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        
        for (int i = 0; i < nums.length - 2; i++) {
            // 跳过重复
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            
            Map<Integer, Integer> map = new HashMap<>();
            for (int j = i + 1; j < nums.length; j++) {
                int complement = -nums[i] - nums[j];
                
                if (map.containsKey(complement)) {
                    result.add(Arrays.asList(nums[i], complement, nums[j]));
                    
                    // 跳过重复的nums[j]
                    while (j + 1 < nums.length && nums[j] == nums[j + 1]) {
                        j++;
                    }
                }
                map.put(nums[j], j);
            }
        }
        
        return result;
    }
}