
--------------------------------------------6-------------------------------------------------------
O(1)
常数时间，比如数组按索引访问、哈希表查找。


O(log n)
对数时间，比如二分查找、平衡二叉树查找。


O(n)
线性时间，比如遍历数组、查找最大值。


O(n log n)
线性对数时间，比如归并排序、快速排序（平均）、堆排序。


O(n²)
平方时间，比如冒泡排序、选择排序、插入排序（最坏）。


O(n³)
立方时间，比如三重嵌套循环。


O(2^n)
指数时间，比如递归解决子集问题、暴力解 NP 问题。


O(n!)
阶乘时间，比如全排列生成、旅行商问题暴力解。
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。

自解：for target + 两数之和
-4 -1 0 1 2 

## 待再思考
O(1)
常数时间，比如数组按索引访问、哈希表查找。


O(log n)
对数时间，比如二分查找、平衡二叉树查找。


O(n)
线性时间，比如遍历数组、查找最大值。


O(n log n)
线性对数时间，比如归并排序、快速排序（平均）、堆排序。


O(n²)
平方时间，比如冒泡排序、选择排序、插入排序（最坏）。


O(n³)
立方时间，比如三重嵌套循环。


O(2^n)
指数时间，比如递归解决子集问题、暴力解 NP 问题。


O(n!)
阶乘时间，比如全排列生成、旅行商问题暴力解。
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。

自解：for target + 两数之和
-4 -1 0 1 2 

## 待再思考


## java原生数组删除某个值，集合常用方法

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        for(int i = 0;i<lists.length;i++){
        	List lists = new Arraylist(Array.asList(nums)) ;
        	//从数组排除这个数
    		List listsde = new ArrayList(lists.remove(i));
        	//对剩下的数组进行遍历
        	Map<Integer,Integer> map = new HashMap<>();
    		for(int j=0;j<lists.length;j++){
    			if(map.containsKey(lists[i]-listsde[j])){
    				List anser = new Arraylist(Arraylist.asList(new int[]{map.get(lists[i]-listsde[j],j)}));
    				List<List<Integer>> anserq = new Arraylist();
    				anserq.add(anser);
    			}
    			map.add(listde[j],j);
    		}
        	
        }
        return anserq;
    }
}
```



-----------------------------------7-----------------------------------------
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
                             1 . 1  ...    1 1 ..  1
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
示例 2：

输入：height = [4,2,0,3,2,5]
输出：9

栈 遇到比存在里面的任意值大的结算，根据索引     遇到小的存进去，跟新指向

1 0 2结算 
2 1 0 1 结算 指队列中向第二小的数
2 3 结算
3 2 1 2 结算
3 2 1 
